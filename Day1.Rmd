---
title: "Basic Introduction to R"
---

## The Interactive Interpreter

Open R and type `2 + 2`.  R tells you that the answer is `4`. Congrats!  You are now using R. This is the most basic way to interact with the interpreter.  Later we will see how you can save a complicated series of commands to a script file and excecute them automatically. 

## Assignment

Sometimes it is useful to assign the results of computations to a named variable that we will use later.  We can create a named variable using the `<-` assignment operator.  For instance, we can do the following. **Note** It is technically possible to use the `=` symbol for assignment, but this is bad practice, as it causes problems down the line.  Get used to typing the `<-` symbol.  

```{r}
myVariable <- 2 + 2
```

Now the result from this computation is assigned to `myVariable` and saved for later use.  Later, we can call this  variable like so: 

```{r}
myVariable * myVariable
```

## Vectors

A vector is a series of values stored in a single object.  You can create a vector using the `c()` function (**c** stands for **combine**). **Note**: you can only store a single type of data in a vector (e.g. numeric or character data).

```{r}
vector1 <- c(1,2,3,4,5,6,7,8,9,10)
vector2 <- c(11,12,13,14,15,16,17,18,19,20)
```

Vectors are very powerful, because many of the basic functions and operations in R are **vectorized**, meaning that they operate on all elements of a vector in sequence.  For example, to add the elements of `vector1` with the corresponding elements in `vector2`, you simply add the vectors, because the `+` function is vectorized. You can assume that **most** of the base functions in R are vectorized. This is one of the fundamental advantages of R. 

```{r}
vector1 + vector2
```

### Accessing values within a vector

Vectors can be **indexed** with brackets `[]` to get a subset of values.  What value do you get by typing `vector2[3]` in the interpreter? What about `vector2[3:5]`? HINT: the `:` operator makes a sequence of integers.

### <span class="mega-octicon octicon-puzzle"></span> Challenge 

Explain to the person sitting next to you how this works. HINT: R evaluates expressions 'from the inside out', with regards to brackets and parentheses.

```{r}
vector2[c(1,4,5)]
```

## Logical Tests and Logical Indexing

Logical tests are assertions that R evaluates as either with `TRUE` or `FALSE`. For instance, you might assert that "1 plus 1 equals 10 minus 8"? In R that looks like:

```{r}
1 + 1 == 10 - 8
```

R tells us that this is `TRUE`.  Note the double equals symbol, which means something different than a single equals symbol. The logical operators are:

*  `==` is equal to
*  `!=` does not equal
*  `>` greater than
*  `<` less than
*  `>=` greater than or equal to
*  `<=` less than or equal to

Like most things in R, logical tests work on vectors.  Remember `vector2` from before? Lets find out which values are greater than 19. 

```{r}
vector2 > 17
```

This becomes useful when you only want a subset of values from a vector using logical indexing.  To get **only** the values of `vector2` that are greater than 17, we can use a logical (AKA boolean) vector.  

```{r}
vector2[vector2 > 17]
```

You can also pass complicated logical tests using the AND operator `&` or the logical OR operator `|`

```{r}
vector2[vector2 > 17 & vector2 < 20]
vector2[vector2 > 17 | vector2 == 13]
```

## Data Frames

Data frames are a convenient way of storing multiple related vectors of data together in a single object.  They are analogous to a spreadsheet where each row corresponds to an individual (e.g., specimen, species) and each row corresponds to some observation about that individual. Usually, you will use the `read.table()` function to read a dataframe directly from a .csv or .txt file that you have saved from MS Excel.

### Accessing data in a dataframe

Using the built in dataframe `iris`, you can explore how to access data within a dataframe.  The most common ways are with the `$` syntax and with the `[row,column]` syntax. `$` is used to access a named column within an dataframe.  The `[row, column]` syntax is used to identify the index number of the row and column desired.  Note that leaving a blank indicates ALL rows or columns.  So `iris$Species` is the same as `iris[,5]`.

```{r}
#first few rows of iris
head(iris)

#get the Sepal.Length column
iris$Sepal.Length

#get the value in the first row, third column
iris[1,3]

#get the whole first row
iris[1, ]
```

## Functions

Functions are the heart of R. A function is just a series of commands that is assigned a name.  Functions accept **arguments**, perform a series of commands using the argument values, then **return** a single object. You can create your own functions (and you will!) but there are many hundreds of pre-defined functions available for your use. 

You call a function by typing its name, followed by parentheses containing any **arguments** necessary. For example, the `print()` function simply prints a single argument to the consonsole.

```{r}
print("The quick brown fox jumped over the lazy dog.")
```

There is a function called `rnorm()` that produces random numbers from a normal distribution.  It has three arguments: `n` indicates the number of random numbers to produce, `mean` indicates the mean of the desired distribution, and `sd` sets the desired standard deviation of the points. 

### <span class="mega-octicon octicon-puzzle"></span> Challenge 

1.  Use `rnorm` to create a vector representing student grades from an Anthropology 101 course with  200 students, mean grade of 75%, and a standard deviation of 10. 

2.  Make a histogram of this grade distribution using the `hist()` function. Note: You can see all the arguments and default values by using the `?` operator like this `?hist`.

## Scripts

Typing commands interactively into the command-line interpreter is fine for experimentation, but ultimately we want to save every single command to a text file, so that this can be run later, shared with collaborators, or published online with the article as supplementary information.  **This element of reproducibility is a critical benefit of doing scripted data analysis.** In Rstudio, you can create a new script by using the File >> New File menu. 

### <span class="mega-octicon octicon-puzzle"></span> Challenge 

1.  Create a new script file.     
2.  Create a variable called `numbers` that contains the numbers 1 through 100.  **Hint** use the `?` operator to investigate the `seq` function or explore the `:` operator.
3.  Create a new vector that contains only the elements of `numbers` that are greater than 36.  Save this to a variable called `bignumbers`
4.  Calculate the natural logarithm of each value in `bignumbers`. 
5.  Make a histogram of `bignumbers` using the `hist()` function
6.  Save your script file, then clear your workspace to delete ALL saved variables, and re-run your script file to redo all the steps.

## R Markdown
R Markdown documents are like scripts, but better.  Instead of creating regular .R script files, you  create a special type of file called an R markdown file, which allows you to mix human readable text with snippets of R code. At any time you can "knit" the R Markdown file, which causes the code snippets to be run. Any results (figures or text output) get combined with the human readable parts, and combined into a single pdf, word doc, or html file.  This is how I work mostly....basically writing the methods section of the paper interactively as I write the analysis code. This website is written entirely in Rmarkdown.

### Example R Markdown document

This sentence is just normal text, made for humans to read.  The following bit is a "code chunk", which is set off by the \`\`\` characters and consists of actual R code that gets run, and the results knitted back into the document. You can also put R code inline like this.  What is 2 + 2? The answer is \`&#114; 2 + 2`.

\`\`\`{r examplechunk}<br>
x <- rnorm(100)<br>
y <- (x * 0.3) + rnorm(100, sd=0.2)<br>
plot(x,y,pch=16)<br>
\`\`\`

Here is some more human readable text right after the code chunk.  

### Output of R Markdown after knitting


This sentence is just normal text, made for humans to read.  The following bit is a "code chunk", which is set off by the \`\`\` characters and consists of actual R code that gets run, and the results knitted back into the document. You can also put R code inline like this.  What is 2 + 2? The answer is `r 2 + 2`.

```{r echo=FALSE}
x <- rnorm(100)
y <- (x * 0.3) + rnorm(100, sd=0.2)
plot(x,y,pch=16)
```

Here is some more human readable text right after the code chunk. 


## Packages

One of the most important features of R is that it is has a vast ecosystem of user-contributed packages, which extend the base functionality of R.  Packages can be installed from the command line `install.packages('ggplot2')` or by using the graphical package manager in Rstudio using the Tools > Install Packages menu. Each time you want to use functions from a package, you must make the package available with the `library()` function. E.g. `library(ggplot2)`.

## Data Input

Getting data into R can be somewhat frustrating for new users.  This is mainly because we humans (the author especially) tend to be sloppy when collecting data in a spreadsheet.  R has rigid expectations.  It expects each column of a text file (usually exported from an Excel sheet) to have a single type of data (text, numeric, factor), plus an optional header row. 

The primary function for reading data into R is the `read.table()` function.  This function reads plain text files (.txt or .csv) and creates a dataframe in R from the resulting data.  There are a variety of arguments to `read.data()`, the most important of which are:

*  `file` = The full path to the file on your computer as a text string. (Use the forward slash `/`, even on Windows.)
*  `sep` = the character that separates columns in your text file.  The default is `" "`, which kind of sucks because most of our files will be separated by either `\t` or `,`.
*  `header` = Whether or not there is a header row in your text file.  Defaults to `FALSE`, but usually we need it to be `TRUE`.


### <span class="mega-octicon octicon-puzzle"></span> Challenge <span class="mega-octicon octicon-puzzle">

Read in the file called [femur_lengths.txt](https://dl.dropboxusercontent.com/u/1648032/datasets_for_R_course/femur_lengths.txt). Save to an object called `femora`.

## Data Output

Usually, I would recommend not writing out modified data frames to text files.  Far better to have a single input file, and to do all necessary manipulations in your saved R script file. But, if you have huge datasets or need to use another statistical program, it is sometimes necesary to save a dataframe out as a text file.  You can do this with `write.table()`

*  `x` = The name of the data frame to be saved. 
*  `file` = Path to the output file.  You can't use `file.choose()` though.
*  `quote` = Do you want quotation marks around strings? Defaults to `TRUE`
*  `sep` = Same as for `read.table()`
*  `row.names` = Do you want row names?  Defaults to `TRUE`, but usually you will set to `FALSE`/


### <span class="mega-octicon octicon-puzzle"></span> Challenge <span class="mega-octicon octicon-puzzle">

Add a new column of log transformed lengths to the femur length dataset and then write out the new file to the Desktop.

```{r include=FALSE}
library(RCurl)
theFile <- getURL("https://dl.dropboxusercontent.com/u/1648032/datasets_for_R_course/femur_lengths.txt")
femora <- read.table(text=theFile, header=TRUE, sep = "\t")
```

```{r include=FALSE}
femora$family <- c(rep("Bovidae", 10), rep("Muridae", 12), rep("Hominidae", 18))
write.table(femora, "~/Desktop/femur_lengths_family.txt", quote=FALSE, sep="\t", row.names=FALSE)
```

---
title: Programming & Wrangling
output: 
  ioslides_presentation:
    widescreen: true
---


## programming

R is a programming language, which means that it gives you all the tools you need to automate repetitive tasks.  There are three (or more) main ways to do this:

* `for` loops
* the `lapply()` function
* the `dplyr` package

## for loops

`for` loops will be familiar if you have ever used any other programming languages.  The basic structure looks like this:

```{r results='hide'}
vector <- 1:10
for(i in vector){
  #do something with i
}
```

## for loops

Here is a (slightly) more complicated example. 

```{r }
myVector <- 1:10
for(counter in myVector){
  result <- paste("counter ^ 2 = ", counter^2)
  print(result)
}
```


## explanation of previous loop

-  We loop over a vector `1:100`, and sequentially assign its values to a temporary variable we are calling `counter`. (Note: we can call this variable whatever we want.) 
-  Then R does what is within the curly braces `{}` for each iteration of the loop.
-  In this case, it pastes together some text with the square of the value of `counter` and prints this all to the console. 

-  <span class="mega-octicon octicon-question"></span> After running the above code, what is the value of `counter`? What is the value of `myVector`? Has this value changed?

## getting stuff out of a loop

-  Create a results vector in advance that is the same length as the vector we are looping over
-  Then save the results each time in the appropriate slot. 

```{r}
myVector <- runif(5, min = 1, max=10); myVector
results <- numeric(5)
for(each in 1:length(myVector)){
  results[each] <- paste(myVector[each], "^ 2 = ", myVector[each]^2)
}

results[3]

```

## `if` statements

-  Often during a loop, you may want to do a test and do something different based on the results of the test. 
-  Imagine a vector of germination outcomes from a seed experiment. 
-  0 indicates the seed did not germinate due to insect predatoin
-  1 indicates that it did not germinate but no insect predation occurrend
-  2 indicates that the seed germinated. 

We can use the `if()` function to evaluate the outcome and provide context specific output. 

---

```{r}
outcomes <- c(0,1,0,2,0,1,0,2,0,1,0,1,0,0)
for(trial in outcomes){
  if(trial == 2) print("Welcome to the world, plantling!")
  else print("RIP")
}
```

## Challenge

Write a `for` loop to examine the law of large numbers to illustrate how, as sample size increases, estimates of the mean of a population converge on the true value.  Do this in the following steps:

* create a numeric results vector of length 2000
* loop over each integer `i` from 1 to 2000
* at each iteration use the `rnorm()` function to simulate a sample of size `i` from a population with a mean of 100 and standard deviation of 30.
* calculate the mean of this sample, and be sure to save these results to the appropriate place in the results vector
* finally, make a plot of the results with the integers 1 to 2000 on the x axis, and the corresponding value from the results vector on the y axis

<!-- ## solution -->

<!-- ```{r} -->
<!-- results <- numeric(2000) -->
<!-- for(i in 1:2000){ -->
<!--   results[i] <- mean(rnorm(n=i, mean=100, sd=30)) -->
<!-- } -->
<!-- plot(1:2000, results, pch=16) -->
<!-- ``` -->


## `lapply()`

<div class="columns-2">

The function `lapply()` is like a `for` loop, but is optimized and explicitly functional.

`lapply()` usually takes two arguments 

-  `X` which is a list or a vector to loop over
-  `FUN` which is a function to apply to each element of `X`.  

Thus, `FUN` must be able to accept any element of `X` as an argument. 

```{r}
x <- c("dog","cat", "cucumber")
lapply(x, FUN=nchar)
```
</div>

## Writing your own functions


Functions are the best way to encapsulate code that you want to repeat again and again.  

A function accepts **arguments** and **returns** a single (and only a single) object.

Variable names defined within a function only exist within the function (not within the global environment). 

## Writing your own functions

```{r}
is.even <- function(number){
  if(number %% 2 == 0) {return("The number is even")}
  else {return("The number is not even")}
}

is.even(1233)
is.even(1234)
is.even(-1.2)
```

## Lists

The "l" in `lapply()` stands for "list", because that's what you get as a result. 

**lists can hold any type of data, not every element needs to be the same type.**

```{r}
myList <- list(firstOne=1, nextOne="too", lastOne=rnorm(10))
myList
```

## often use double brackets `[[]]` to index a list

```{r}
myList[[3]]
myList[3]
```

For five marks....what is the difference?

## `[[]]` versus `[]`


<img src='../../images/pepper.png' width=900>


## lists can (optionally) have named elements, that can be accessed using the `$` operator 

```{r}
myList$nextOne
```

Where have you seen the `$` operator before?

What does this suggest about the relationship between list and dataframes?

## Lists are useful because of their flexibility. 

We can store complex results from each iteration, and then come back to these results later. 

```{r}
# note, we must accept an argument
# even if we don't do anything with this argument.
summarizeRandom <- function(n){
  sample <- rnorm(n)
  mySummary <- summary(sample)
  return(mySummary)
}

sampleSizes <- 100:200
myResults <- lapply(sampleSizes, FUN=summarizeRandom)
myResults[1:3]
```


## the dplyr package

user-contributed package that has kind of revolutionized working with data in R.

It provides a consistent and simpler interface to do things that you could also do using loops or base functions in R. 

It is less flexible than a for loop or `lapply()`, but it is easier to use, and works for the most common data manipulation tasks. 

## the dplyr package

`dplyr` is very consistent

it assumes that you are starting with a dataframe, doing something to that dataframe, and finishing with a different dataframe. 

Many of the base R functions operate on atomic vectors, which makes it more complicated to apply them to dataframes.) 

`dplyr` introduces a series of simple 'verbs' that describe many common data manipulation tasks. 

## Challenge 

We will use a dataset on student loans in public and private universities.

Read in this dataset called [DMV_2014_Q3_Undergrad_DirectLoans.txt](http://wabarr.github.io/hompal-stats/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt) and save it to a variable called `loans`.


```{r echo = FALSE}
loans <- read.table("http://wabarr.github.io/hompal-stats/datasets/DMV_2014_Q3_Undergrad_DirectLoans.txt", sep=",", header=TRUE)
```


## The basic dplyr verbs

There are a few basic functions in `dplyr`

The first argument to these functions is always the dataframe that you want to manipulate. 

Within these function calls, you can refer to the names of columns in the dataframe without quotation marks and without the usual `$` syntax. 

```{r warning=FALSE, message=FALSE}
library(dplyr)
```

## `filter()` 

This function selects a subset of rows meeting some criterion.  Note that the result is a dataframe. 

```{r warning=FALSE, message=FALSE}
filter(loans, School=="GEORGE WASHINGTON UNIVERSITY")
```

## `arrange()`

This function is like the "sort" function in MS Excel.  You simply provide a list of column names to sort by:

```{r}
arrange(loans, State, SubsidizedDL)
arrange(loans, State, desc(SubsidizedDL))
```

## `select()`

This function pulls out colums of interest.  You can select ranges of columns using the `:` operator syntax. (Note: usually this only works with numeric data, but this is a special usage defined in the `dplyr` package)

```{r}
select(loans, State, SubsidizedDL)
select(loans, -State, -SubsidizedDL)
select(loans, State:SubsidizedDL)
```

## `distinct()`

This function extracts the distinct rows.  It is most useful when combined with select

```{r}
distinct(loans)
distinct(select(loans, State, School_Type))
```

## `mutate()`

Adds new columns that are some function of existing columns

```{r}
mutate(loans, Total_Loans = SubsidizedDL + UNSubsidizedDL)
```

## `rowwise()`

Mutate works as expected when you want to manupulate whole columns at once, but sometimes you want to do something on a row-by-row basis.

For example: this code doesn't work as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(myDF, sum=sum(x, y))
```

## `rowwise()`

But this code computes the sum on a row-by-row basis, as you might expect

```{r}
myDF <- data.frame(x=c(1,2,3), y=c(10, 11, 12))
mutate(rowwise(myDF), sum=sum(x, y))
```


## `summarise()`

Summarizes data into a single row.  This may seem not that useful, but it will become useful when we start grouping data. 

```{r}
summarise(loans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```


## Grouping Data

These functions above get really powerful when you start grouping data based on factors in your dataset.

##`group_by()`

```{r}
groupedLoans <- group_by(loans, State)
summarise(groupedLoans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```

## Chaining operations

`dplyr` also provides a way of chaining together commplicated operations with the `%>%` operator.

This prevents having to save intermediate steps, or to have a complicated series of nested functions.

Note that the resulting dataframe from each step is passed as the first argument to the next function in the chain.

## Chaining operations

```{r}
group_by(loans, School_Type) %>%
  mutate(Total_Loans = SubsidizedDL + UNSubsidizedDL) %>%
  select(-State) %>%
  summarise(mean_total_loans = mean(Total_Loans, na.rm=TRUE))
```

## Chaining works with non-`dplyr()` functions too

```{r warning=FALSE}
#chained syntax
rnorm(1000, mean=20, sd=1.4) %>% log %>% hist(main="my nice histogram")


#compare with nested function calls 

hist(log(rnorm(1000, mean=20, sd=1.4)))
```

## `do()`

do anything to grouped data

```{r}
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
```

## `do()`


<pre class="prettyprint lang-r">
linearModels <- loans %>% group_by(State) %>%
  do(regression=lm(UNSubsidizedDL~SubsidizedDL, data=.))
linearModels
</pre>

```{r}
linearModels %>% 
  summarize(sum=summary(regression)$r.squared)
```


## Challenge

Using the `diamonds` dataset that is built in to the `ggplot2` package:

*  calculate the mean price of diamonds for each of the different clarity ratings
*  create a new column called `volume` that is the product of x, y and z
*  plot `volume` against `carat`

## More info

A more complete introduction is available in the [`dplyr` vignette](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

More info on `magrittr` [can be found here](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).
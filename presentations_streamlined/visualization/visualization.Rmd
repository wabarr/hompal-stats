---
title: "Visualizing Data"
output: 
  ioslides_presentation:
    widescreen: true
---


## I am opinionated when it comes to graphics in R. {.build}

Base graphics in R are a bit kludgy.

I prefer to use the `ggplot2` package. 

This package is part of a larger group of packages called `tidyverse`.  The easiest thing to do install the `tidyverse` rather than each package separately. 

You need to install this package using the standard package manager: Tools > Package Manager. Then you will load the package using the command `library(tidyverse)`.

`ggplot2` provides a convenient function called `qplot()` for making quick plots that don't require a lot of customization. 

## Basic Plotting

We will use a built in dataset called `diamonds`.  Lets take a look at the head (i.e. first few rows) of this dataset.

```{r warning=FALSE, message=FALSE}
library(tidyverse)
head(diamonds)
```


## Univariate plot {.columns-2}

The simplest usage is to provide a variable for the x axis, and a dataframe in which to look for this variable.  

`qplot()` will attempt to guess the best `geom` (graphical geometric representation) with which to display the data. 

Here we plot a histogram of diamond weights. 

```{r fig.width=5}
library(tidyverse)
qplot(x=carat, data=diamonds)
```

## Bivariate Plot

If we specify an additional variable for the y axis, then the default `geom` is a scatter of points.

This time we will also specify a value for `main` which is the main title. 

```{r cache=TRUE, fig.width=10, fig.height=3}
qplot(x=carat, y=price, data=diamonds, main="Diamond Weight by Price")
```

## Boxplot {.build .columns-2}

Now lets plot clarity by carat. 

```{r cache=TRUE, fig.width=3.5, fig.height=3.5}
qplot(x=clarity, y=carat, data=diamonds)
```


Need to specify our `geom`.

We ask for `geom='boxplot'`

```{r cache=TRUE, fig.width=3.5, fig.height=3.5}
qplot(x=clarity, y=carat, 
      data=diamonds, geom="boxplot")
```

## Layers {.build}

Add a line representing a linear regression. Start with the bivariate plot, then add a new layer. 

```{r cache=TRUE, fig.width=10, fig.height=3}
weight_by_price <- qplot(x=carat, y=price, data=diamonds, main="Diamond Weight by Price")

weight_by_price + stat_smooth(method="lm")
```

## Challenge 

The relationship on the previous plot is clearly not linear.  

Make the same plot, but with both variables logged. 

Don't save logged variables to a variable, log the variables on-the-fly when you make the plot. 

## Color, Size, Shape, Fill {.columns-2 .build}

Visualize a third variable by changing:

>- color or fill
>- shape or size of points 

```{r cache=TRUE, fig.height=3, fig.width=5}
qplot(x=carat, y=price, 
      data=diamonds, color=clarity)
qplot(x=carat, y=price, 
      data=diamonds, shape=cut)
```

## Facets {.build}

When we have so many data points, it is hard to tell what is going on.

It would be nice to have a grid of sub-plots, so we can see the effect of these factors on the relationship between price and size. 

We can use the `facets` argument and tell it which factors we want to use, as in `facets=row_var~column_var`

## Facets  {.build}

```{r cache=TRUE, fig.width=10, fig.height=4}
qplot(x=carat, y=price, data=diamonds, 
      main="Diamond Weight by Price", facets=cut~clarity)
```

## Themes - Customize look and feel

`theme_bw()` which gets rid of the default grey background. 

You can also specify a value for the base text size, to increase size for presentations, etc. All the text elements will scale intelligently. 

Also check out `theme_classic()`

## Themes - Customize look and feel

```{r cache=TRUE, fig.height=4}

qplot(x=carat, y=price, data=diamonds, 
      main="theme_bw", color=clarity) + 
  theme_bw(20)

```

## Themes - Customize look and feel

```{r , fig.height=4}
qplot(x=carat, y=price, data=diamonds, 
      main="theme_classic", color=clarity) + 
  theme_classic(20)
```


## The real `ggplot()`

You can't get the full benefits of ggplot using the `qplot()` shortcut.

Plots are comprised of the following elements:

## The real `ggplot()` {.build}

**background elements** (shared by all layers in a plot)

> - <span class='red2'>data</span> - a dataframe which applies to all layers
  - `ggplot` works best when everything you need for your plot is in the same dataframe
> - <span class='red2'>mapping</span> - mapping of data values into plot values (either coordinates or aesthetic properties like color values)

**facets (optional)** - specification of subplots within a plot, mapped to a column in the dataframe

## The real `ggplot()` {.build}

**layers which are layered over the background**

> - <span class='red2'>geom</span> - choice of how to graphically represent the data
> - <span class='red2'>stat</span> - a statistical transformation of rows in the dataframe (often this is the identity transformation)
> - you can also specify new values for `data` and `mapping` that only apply to a particular layer


## A full example

First we set up the background: 

```{r cache=T}
background <- ggplot(data = diamonds, aes(x = clarity, y=price))
```

<span class="mega-octicon octicon-question"></span> What happens when you type `background` in the interpreter at this point?

## A full example

Now we add a boxplot layer:

```{r cache=T, fig.width=10, fig.height=4}
with_boxplot <- background + geom_boxplot(aes(fill=cut))
with_boxplot
```

## A full example

Finally, I style my plot with a theme, and make a couple of tweaks

```{r cache=T, fig.width=10, fig.height=4}
with_boxplot + theme_bw(20) + 
  labs(title="Price by Clarity") + scale_y_continuous(limits=c(0,25000)) + 
  annotate("text", x=4.5, y=23000, label="Lots of outliers", size= 4)
```


   
## For reference: the `ggplot()` workflow

*   invoke the `ggplot()` function to set background elements which will apply to all layers.
    * supply a base dataframe
    * use `aes()` to map dataframe columns to aesthetics. Things you can set include
        * `color`
        * `fill` (the color of polygons or boxplots)
        * `shape`
        * `size` 
        * `alpha` (i.e. transparency)
    *   Anything not getting mapped to a column (e.g. `color="blue"`) doesn't go inside a call to `aes()`
    *   Use `facet_grid()` or `facet_wrap()` to add faceting formula. 
    
## The `ggplot()` workflow

*   Add layers to the plot, usually using one of the `geom_xxx()` functions like:
    *  `geom_point()`
    *  `geom_histogram()`
    *  `geom_bar()`
    *  `geom_path()`, `geom_rect()`, `geom_polygon()`
    *  `geom_abline()`
    *  `geom_text()`
    *  `geom_hline()` and `geom_vline()`
    *  **Note** you can map aesthetics specific to a layer by supplying the appropriate arguments to these functions
    *  **Warning** most of these functions will automatically inherit the aesthetics from the background.  If you want to override this behavior (e.g. to use a different dataframe), you can use the argument `inherit.aes=FALSE`

## The `ggplot()` workflow

*   add an annotation layer `annotate()` to your plot
*   Style the plot and tweak axes etc.
    * Themes are a useful shortcut 
    * There are some helper functions for tweaking plots
      * `labs(x="The X axis label", title="my nice little graph")`
      * `guides()` to tweak legend
      * `scale_x_continuous(limits=c(0,10))` to customize x scale
      * `scale_fill_xxx()` and `scale_color_xxx()` for customizing color choices    
*   Export the plot in a useful format using `ggsave()`
*   Submit for publication.

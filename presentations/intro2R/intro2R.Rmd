---
title: Basic Intro to R
output: 
  ioslides_presentation:
    widescreen: true
---


## The Interactive Interpreter {.build}

Open R and type `2 + 2`.  R tells you that the answer is `4`. 

Congrats!  You are now using R. 

This is the most basic way to interact with the interpreter.  

Later we will see how you can save a complicated series of commands to a script file and execute them automatically. 

## Assignment {.build}

Sometimes it is useful to assign the results of computations to a named variable that we will use later.

We can create a named variable using the `<-` assignment operator.  

**Note** It is technically possible to use the `=` symbol for assignment, but this is bad form.  Get used to typing the `<-` symbol.  

```{r}
myVariable <- 2 + 2
```

Now the result from this computation is assigned to `myVariable` and saved for later use.  Later, we can call this  variable like so: 

```{r}
myVariable * myVariable
```

## Atomic vectors {.build}

An atomic vector is a series of values stored in a single object.  

You can create a vector using the `c()` function (**c** stands for **combine**). 

**Note**: you can only store a single type of data in a vector (e.g. numeric or character data).

```{r}
vector1 <- c(1,2,3,4,5,6,7,8,9,10)
vector2 <- c(11,12,13,14,15,16,17,18,19,20)
```

## Atomic vectors {.build}

Many of the basic functions and operations in R are **vectorized**, meaning that they operate on all elements of a vector in sequence. 

For example, to add the elements of `vector1` with the corresponding elements in `vector2`, you simply add the vectors, because the `+` function is vectorized. 

This is one of the fundamental advantages of R. 

```{r}
vector1 + vector2
```

## Atomic vectors {.build}

What happens when I try this?

```{}
vector3 <- c(21,22,23,24,25,26,27,28,29,"thirty")
```

What type of vector is `vector3`?

What happens when I do this? `vector2 + vector3`

## Accessing values within a vector {.build}

Vectors can be **indexed** with brackets `[]` to get a subset of values.

What value do you get by typing `vector2[3]` in the interpreter? 

What about `vector2[3:5]`? HINT: the `:` operator makes a sequence of integers.

## Challenge 

Extract the first, fifth, and ninth element of `vector2` that you created earlier.

## Negative Indexing {.build}

When you use negative indices, then the referenced elements are **removed** from the resulting vector. 

```{r}
dwarves <- c("Dopey", "Gimli", "Larry")
dwarves[-3] #real dwarves
```

**Note**: comments using the octothorpe (AKA the hashtag #) are for people

## Challenge 

Remove the 1st, 5th and 9th elements from `vector2`

## Logical Tests {.build}

Logical tests are assertions that R evaluates as either `TRUE` or `FALSE`. 

For instance, you might assert that "1 plus 1 equals 10 minus 8"? 

In R that looks like:

```{r}
1 + 1 == 10 - 8
```

R tells us that this is `TRUE`.  

Note the double equals symbol, which means something different than a single equals symbol.

## Logical operators

The logical operators are:

*  `==` is equal to
*  `!=` does not equal
*  `>` greater than
*  `<` less than
*  `>=` greater than or equal to
*  `<=` less than or equal to

## Logical indexing {.build}

Like most things in R, logical tests work on vectors. 

Remember `vector2` from before? 

```{r}
vector2
```

Lets find out which values are greater than 17. 

```{r}
vector2 > 17
```

## Logical indexing {.build}

This becomes useful when you only want a subset of values from a vector using logical indexing.

To get **only** the values of `vector2` that are greater than 17, we can use a logical (AKA boolean) vector.  

```{r}
vector2[vector2 > 17] 
```

You can also pass complicated logical tests using the AND operator `&` or the logical OR operator `|`

```{r}
vector2[vector2 > 17 & vector2 < 20]
vector2[vector2 > 17 | vector2 == 13]
```

## Assignment & Indexing {.build }


You can also use `<-` to replace particular elements in a vector.

```{r}
primates <- c("gorilla", "gibbon", "langur", "gibbon", "gorilla")
primates

primates[3] <- "bushbaby"
primates

primates[primates == "gorilla"] <- "chimpanzee"
primates

```

## Factors {.build}

A factor is a special type of vector for storing categorical data.  


```{r}
pets <- factor(c("cat", "cat", "dog", "pony", "dog", "dog"))
pets
```

R will now treat this differently from other vectors.

These come in useful later on, when we want to summarize by different factor levels.  

## Ordered factors {.build}

By default, R assumes the order of the levels in your factor is alphabetical.

You can change this by replacing the normal factor `pets` with a new ***ordered*** factor

```{r}
pets <- ordered(pets, levels=c("pony", "dog", "cat"))
pets
```

## Data Frames {.build}

Data frames store related vectors of data together in a single object.

They are analogous to a spreadsheet:

> - each row corresponds to an individual (e.g., specimen, species)
> - each column corresponds to some observation about that individual

You will use the `read.table()` function to read a dataframe directly from a .csv or .txt file

## Accessing data in a dataframe {.build}


`$` is used to access a named column within an dataframe

The `[row, column]` syntax is used to identify the index number of the row and column desired

## Accessing data in a dataframe {.build}

Lets extract particular data within the built-in dataframe `iris`

```{r}
head(iris)
```

## Getting data by named column 

```{r}

iris$Sepal.Length

```

## Getting data by row and column number

```{r}
iris[1,3]

```

## Getting a whole row of data {.build}

```{r}
iris[1, ]
```

Note that leaving a blank indicates ALL rows or columns.  

So `iris$Species` is the same as `iris[,5]` because the fifth column of the `iris` dataframe is named 'Species'

## Creating a new column with `$` {.build}

You can also create new columns in a dataframe using the `$` operator. 

There is no colum names `Petal.Area`

```{r}
iris$Petal.Area
```

But we can add one

```{r} 
iris$Petal.Area <- iris$Petal.Length * iris$Petal.Width
iris$Petal.Area
```

## Adding a new column with `$` {.build}

<span class="red2">Note:</span> Adding a calculated column like this is less error prone and more repeatable than doing it in Excel.....

You should store the data in a spreadsheet, and then manipulate it in R. 

## Functions {.build}

Functions are the heart of R.

A function is just a series of commands that is assigned a name.  

Functions

> - accept **arguments**
> - perform a series of commands using the argument values
> - **return** a single object. 

You can create your own functions (and you will!) but there are many hundreds of pre-defined functions available for your use. 

**A huge part of the learning curve of R is learning which functions exist, which is why they invented google.com!** 

## Functions {.build}

You call a function by typing its name, followed by parentheses containing 0 or more **arguments**.

Arguments are the way you pass data and/or options to a function. 

For example, the `paste()` function simply pastes together its arguments into a single text string.

```{r}
part1 <- "The quick brown fox"
part2 <- "jumped over the lazy dog."
paste(part1, part2)

```

**Note**: You can see all the arguments and default values for any function using the `?` operator like this `?NameOfFunction`.

## Scripts {.build}

Typing commands interactively into the command-line interpreter is fine for experimentation

Ultimately we want to save every single command to a text file, so that this can be run later, shared with collaborators, or published online with the article as supplementary information.  

**This element of reproducibility is a critical benefit of doing scripted data analysis.** 

In Rstudio, you can create a new script by using the File >> New File menu. 

## Challenge {.build}

> 1.  Create a new script file.     
> 2.  Create a variable called `numbers` that contains the numbers 1 through 100.  **Hint** use the `?` operator to investigate the `seq` function or explore the `:` operator.
> 3.  Create a new vector that contains only the elements of `numbers` that are greater than 36.  Save this to a variable called `bignumbers`
> 4.  Calculate the natural logarithm of each value in `bignumbers`. 
> 5.  Make a histogram of `bignumbers` using the `hist()` function
> 6.  Save your script file, then clear your workspace to delete ALL saved variables, and re-run your script file to redo all the steps.

## R Markdown 

R Markdown documents are like scripts, but allow you to mix human readable text with snippets of R code.

At any time you can "knit" the R Markdown file, which causes the code snippets to be run. 

Any results (figures or text output) get combined with the human readable parts, and combined into a single pdf, word doc, or html file.  

You can create a new Rmarkdown using the File >> New File menu.

## Example R Markdown document

This sentence is just normal text, made for humans to read.  

The following bit is a "code chunk", which is set off by the \`\`\` characters and consists of actual R code that gets run, and the results knitted back into the document. 

You can also put R code inline like this.  What is 2 + 2? The answer is \`&#114; 2 + 2`.

\`\`\`{r examplechunk}<br>
x <- rnorm(100)<br>
y <- (x * 0.3) + rnorm(100, sd=0.2)<br>
plot(x,y,pch=16)<br>
\`\`\`


## Output of R Markdown after knitting


This sentence is just normal text, made for humans to read.  

The following bit is a "code chunk", which is set off by the \`\`\` characters and consists of actual R code that gets run, and the results knitted back into the document. 

You can also put R code inline like this.  What is 2 + 2? The answer is `r 2 + 2`.

```{r echo=FALSE}
x <- rnorm(100)
y <- (x * 0.3) + rnorm(100, sd=0.2)
plot(x,y,pch=16)
```


## Packages

One of the most important features of R is that it is has a vast ecosystem of user-contributed packages, which extend the base functionality of R.  

Packages can be installed from the command line `install.packages('ggplot2')` or by using the graphical package manager in Rstudio in the Packages tab. 

Each time you want to use functions from a package, you must make the package available with the `library()` function. 

## Data Input

Getting data into R can be very frustrating for new users.

This is because we tend to be sloppy when collecting data in a spreadsheet.

R has rigid expectations. 

> - each column of a text file should contain a single type of data (text, numeric, factor)
> - Each row should hold the observations for each column for a single individual
> - That's it. Period.  No extra rows that are just for formatting and don't contain data observations. 

## Data Input

The primary function for reading data into R is the `read.table()` function. There are a few important arguments.

*  `file` = The full path to the file as a text string. (Use the forward slash `/`, even on Windows.) You can also read from a remote URL (i.e. from the web).
*  `sep` = the character that separates columns in your text file.  The default is `" "`, which kind of sucks because most of our files will be separated by either `\t` or `,`.
*  `header` = Whether or not there is a header row in your text file.  Defaults to `FALSE`, but usually we need it to be `TRUE`.


## Challenge 

Read in the file called "femur_lengths.txt" directly from the following URL

http://hompal-stats.wabarr.com/datasets/femur_lengths.txt

Save to an object called `femora`.

Use the `str()` function to examine the data type of each column.  You can also do the same thing in R Studio in the Environment tab. 

Use the `mean()` function to calculate the mean of all the femur lengths.

## Data Output

Usually, I would recommend **not** writing out modified data frames to text files.  

It is far better to have a single input file, and to do all necessary manipulations in your saved R script file. 

But, if you need to write data, do it with `write.table()`

*  `x` = The name of the data frame to be saved. 
*  `file` = Path to the output file.  You can't use `file.choose()` though.
*  `quote` = Do you want quotation marks around strings? Defaults to `TRUE`
*  `sep` = Same as for `read.table()`
*  `row.names` = Do you want row names?  Defaults to `TRUE`, but usually you will set to `FALSE`


##  Challenge 

Add a new column of log transformed lengths to the `femora` dataframe and then write out the new file to the Desktop.

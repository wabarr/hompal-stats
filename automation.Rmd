```{r include=FALSE, echo=FALSE}
options(width = 100)
```
# Automation

R is a programming language, which means that it gives you all the tools you need to automate repetitive tasks.  There are three (or more) main ways to do this:

* `for` loops
* the `apply()` family of functions
* the `dplyr` package

## for loops

`for` loops will be familiar if you have ever used any other programming languages.  The basic structure looks like this:

```{r results='hide'}
vector <- 1:10
for(i in vector){
  #do something with i
}
```

Here is a (slightly) more realistic example. 

```{r }
myVector <- 1:10
for(counter in myVector){
  result <- paste("counter ^ 2 = ", counter^2)
  print(result)
}
```

We loop over a vector `1:100`, and sequentially assign its values to a temporary variable we are calling `counter`. (Note: we can call this variable whatever we want.) Then R does what is within the curly braces `{}` for each iteration of the loop.  In this case, it pastes together some text with the square of the value of `counter` and prints this all to the console. 

<span class="mega-octicon octicon-question"></span> After running the above code, what is the value of `counter`? What is the value of `myVector`? Has this value changed?

Often, we want to do some calculations, and save the results outside of the `for` loop.  To do this, we can create a results vector in advance that is the same length as the vector we are looping over, then we can save the results each time. For instance: we can make a results vector to store the values in the above example, rather than printing them.

```{r}
myVector <- 1:100
results <- numeric(100)
for(counter in myVector){
  results[counter] <- paste("counter ^ 2 = ", counter^2)
}

##now get some of the stored results
results[50]
results[67]
```


### <span class="mega-octicon octicon-puzzle"></span> Challenge

Write a `for` loop to examine the law of large numbers to illustrate how, as sample size increases, estimates of the mean of a population converge on the true value.  Do this in the following steps:

* create a numeric results vector of length 2000
* loop over each integer `i` from 1 to 2000
* at each iteration use the `rnorm()` function to simulate a sample of size `i` from a population with a mean of 100 and standard deviation of 30.
* be sure to save these results to the appropriate place in the results vector
* finally, make a plot of the results with the integers 1 to 2000 on the x axis, and the corresponding value from the results vector on the y axis

```{r include=FALSE,results="hide"}
results <- numeric(2000)
for(i in 1:2000){
  results[i] <- mean(rnorm(n=i, mean=100, sd=30))
}
plot(1:2000, results, pch=16)
```

## lapply + writing your own functions

The function `lapply()` is like a `for` loop, but is optimized and explicitly functional. `lapply()` usually takes two arguments `X` which is a list or a vector to loop over, and `FUN` which is a function to apply to each element of `X`.  Thus, `FUN` must be able to accept any element of `X` as an argument. The clearest way is to write your own function.  

The "l" in `lapply()` stands for "list", because that's what you get as a result.  This is useful, because you allows you to store complex stuff from each iteration.  For example: 

```{r}
# note, we must accept argument
# even if we don't do anything with this argument.
summarizeRandom <- function(x){
  sample <- rnorm(1000)
  mySummary <- summary(sample)
  return(mySummary)
}

myResults <- lapply(1:100, FUN=summarizeRandom)
myResults[1:3]
```


## the dplyr package

This a user-contributed package that has kind of revolutionized working with data in R.  It provides a consistent and simpler interface to do things that you could also do using loops or base functions in R. It is less flexible than a for loop or `lapply()`, but it is easier to use, and works for the most common data manipulation tasks. 

`dplyr` is very consistent: it assumes that you are starting with a dataframe, doing something to that dataframe, and finishing with a different dataframe. (Many of the base functions operate on vectors, which makes it more complicated to apply them to dataframes.) `dplyr` introduces a series of simple 'verbs' that describe many common data manipulation tasks. 

### <span class="mega-octicon octicon-puzzle"></span> Challenge 

We will use a dataset on student loans in public and private universities.  Read in this dataset called 'DMV_2014_Q3_Undergrad_DirectLoans.csv' and save it to a variable called `loans`.

**Note** before getting started, lets convert our `loans` object to a tbl_df object, which is just like a normal dataframe, but doesn't print all its rows to the screen. This function is part of `dplyr`, so we need to load it first. 

```{r echo = FALSE}
loans <- read.table("http://hompal-stats.wabarr.com/datasets/DMV_2014_Q3_Undergrad_DirectLoans.csv", sep=",", header=TRUE)
```

```{r warning=FALSE, message=FALSE}
library(dplyr)
loans <- tbl_df(loans)
```

### The basic dplyr verbs

### `filter()` 

This function selects a subset of rows meeting some criterion.  Note that the result is a dataframe. 

```{r warning=FALSE, message=FALSE}
filter(loans, School=="GEORGE WASHINGTON UNIVERSITY")
```

### `arrange()`

This function is like the "sort" function in MS Excel.  You simply provide a list of column names to sort by:

```{r}
arrange(loans, State, SubsidizedDL)
arrange(loans, State, desc(SubsidizedDL))
```

### `select()`

This function pulls out colums of interest.  You can select ranges of columns using the `:` operator syntax. (Note: usually this only works with numeric data, but this is a special usage defined in the `dplyr` package)

```{r}
select(loans, State, SubsidizedDL)
select(loans, -State, -SubsidizedDL)
select(loans, State:SubsidizedDL)
```

### `distinct()`

This function extracts the distinct rows.  It is most useful when combined with select

```{r}
distinct(loans)
distinct(select(loans, State, School_Type))
```

### `mutate()`

Adds new columns that are some function of existing columns

```{r}
mutate(loans, Total_Loans = SubsidizedDL + UNSubsidizedDL)
```

### `summarise()`

Summarizes data into a single row.  This may seem not that useful, but it will become useful when we start grouping data. 

```{r}
summarise(loans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```


### Grouping Data

These functions above get really powerful when you start grouping data based on factors in your dataset.

###`group_by`

```{r}
groupedLoans <- group_by(loans, State)
groupedLoans

summarise(groupedLoans, meanSubDL = mean(SubsidizedDL, na.rm=TRUE))
```

### Chaining operations

`dplyr` also provides a way of chaining together commplicated operations with the `%>%` operator.  This prevents having to save intermediate steps, or to have a complicated series of nested functions.  Note that the resulting dataframe from each step is passed as the first argument to the next function in the chain. For instance. 

```{r}
group_by(loans, School_Type) %>%
  mutate(Total_Loans = SubsidizedDL + UNSubsidizedDL) %>%
  select(-State) %>%
  summarise(mean_total_loans = mean(Total_Loans, na.rm=TRUE))
```

**Note:** If you like this idea of chaining operations, this actually comes from a separate package called `magrittr`, which `dplyr` relies on.  If you want you can use this in your non `dplyr` code as well. Notice that in the example below, if you are piping to a function that only needs 1 argument, you can leave out the parentheses, and just type the name of the function. 

```{r warning=FALSE}
library(magrittr)
library(ggplot2)

#chained syntax
rnorm(1000, mean=20, sd=1.4) %>% log %>% qplot

#compare with nested function calls 

qplot(log(rnorm(1000, mean=20, sd=1.4)))
```

### <span class="mega-octicon octicon-puzzle"></span> Challenge 

Need to put a challenge here. 

### More info

A more complete introduction is available in the [`dplyr` vignette](http://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

More info on `magrittr` [can be found here](http://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html).